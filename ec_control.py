# -*- coding: utf-8 -*-
"""EC_basic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xkchY_NlzvGeAUS7cr601KCOJfLTZDV9

In the basic algorithm, a random number of positions will be selected based on the mutation rate and new weights will be randomly drawn from a Gaussian distribution with μ = 0, σ = 1 for those positions. Selection will be implemented as a simple truncation selection. Only children will be considered in the selection process (max_age = 1).

In this notebook also: 1) Possibility of selecting parents for the next generation without aging (max_age > generations), 2) Same but with aging (generation > max_age > 1)
Also, Possibility of crossover
"""

import torch
from tqdm import trange, tqdm
import argparse
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict
from itertools import combinations

device="cuda"

#Helper functions

def to_im(ten):
    return ten.cpu().detach().clone().squeeze(1).numpy()


def dround(ten, digits):
    a = 10 ^ digits
    return torch.round(ten * a) / a


def fitness_function(pop, targ):
    return (1 - torch.abs(pop.squeeze(1) - targ)).sum(axis=1) # the smaller the difference, the higher the fitness


# Evolve
def evolutionary_algorithm(args):

    #Setting up
    pop = torch.randn((args.pop_size, args.grn_size)).to(device) # create population of random arrays
    targ = torch.randint(2, size=(1, args.grn_size)).to(device) # create a random target, binary (for better visualisation)
    num_genes_fit=int(args.num_genes_consider*args.grn_size)
    targ = targ[:,:num_genes_fit] # create targets only for relevant genes
    targs = [targ, 1 - targ.detach().clone()] # alternative target is the exact opposite
    curr_targ = 0 # ID of which target is the current one

    # Keeping track

    ages = torch.zeros(args.pop_size)
    max_fits = []
    ave_fits = []
    ave_complex = []
    champions = []
    max_ages = []
    ave_ages = []
    best_grns = []

    diversities = []

    for gen in trange(args.num_generations):

        # Evaluate fitnesses
        fitnesses = fitness_function(pop[:,:args.num_genes_fit], targs[curr_targ])

        max_fits.append(fitnesses.max().item()) # keeping track of max fitness
        ave_fits.append(fitnesses.mean().item()) # keeping track of average fitness
        wandb.log({'max_fits': fitnesses.max().item()}, commit=False)
        wandb.log({'ave_fits': fitnesses.mean().item()}, commit=False)

        # Selection
        perm = torch.argsort(fitnesses, descending=True)
        parent_locs = perm[:args.truncation_size] # location of top x parents in the array of individuals
        children_locs = perm[args.truncation_size:] # location of individuals that won't survive and hence will be replaced by others' children

        #champions.append(state[perm[0]].detach().clone().cpu().squeeze(0).numpy()) # keeping tract of best solution's output
        best_grns.append(pop[perm[0]].detach().clone().cpu()) # keeping tract of best solution
        wandb.log({'best_grns': pop[perm[0]].detach().clone().cpu()}, commit=False)

        ages[parent_locs] += 1 # updating the ages of the individuals
        ages[children_locs] = 0

        parents = pop[parent_locs].detach().clone() # access parents' matricies
        num_child = int(args.pop_size/args.truncation_size) - 1
        children = parents.repeat([num_child,1])  # create copies of parents

        # Mutation
        num_genes_mutate = int(args.grn_size*len(children) * args.mut_rate)
        mylist = torch.zeros(args.grn_size*len(children), device="cuda")
        mylist[:num_genes_mutate] = 1
        shuffled_idx = torch.randperm(args.grn_size*len(children), device="cuda")
        mask = mylist[shuffled_idx].reshape(len(children),args.grn_size) #select genes to mutate
        children = children + (children*mask)*torch.randn(size=children.shape, device="cuda") * args.mut_size  # mutate only children only at certain genes

        pop[children_locs] = children # put children into population

        #a bit unfair comperation because of the sigmoid function that pushes towards 0 and 1

        # Dying due to old age
        old_locs = torch.where(ages >= args.max_age) # get location of old individuals

        if len(old_locs[0]) != 0:
          ages[old_locs] = 0 #reset age

          old_inds = pop[old_locs] # get old individuals' matrices

          num_genes_mutate = int(args.grn_size*len(old_inds) * args.mut_rate)
          mylist = torch.zeros(args.grn_size*len(old_inds), device="cuda")
          mylist[:num_genes_mutate] = 1
          shuffled_idx = torch.randperm(args.grn_size*len(old_inds), device="cuda")
          mask = mylist[shuffled_idx].reshape(len(old_inds),args.grn_size) #select genes to mutate
          old_inds = old_inds + (old_inds*mask)*torch.randn(size=old_inds.shape, device="cuda") * args.mut_size

          pop[old_locs] = old_inds # mutate old individual -> new child

        max_ages.append(ages.max().item())
        ave_ages.append(ages.mean().item())
        wandb.log({'max_ages': ages.max().item()}, commit=False)
        wandb.log({'ave_ages': ages.mean().item()}, commit=False)

        stdivs=torch.std(pop, unbiased=False, dim=0) #stdiv calculcated for each position in the genome, across individuals
        diversity=stdivs.mean()
        diversities.append(diversity)
        wandb.log({'diversities': d}, commit=True)

        if gen % args.season_len == args.season_len - 1: # flip target
            curr_targ = (curr_targ + 1) % 2

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-grn_size', type=int, default=20, help="GRN size") # number of genes in the GRN
    parser.add_argument('-max_iter', type=int, default=10, help="Maximum number of GRN updates") # number of times gene concentrations are updated to get phenotype
    parser.add_argument('-pop_size', type=int, default=10, help="Population size")
    parser.add_argument('-alpha', type=int, default=10, help="Alpha for sigmoid function")
    parser.add_argument('-num_genes_consider', type=float, default=0.7, help="proportion of genes considered for fitness")
    parser.add_argument('-mut_rate', type=float, default=0.1, help="rate of mutation (i.e. number of genes to mutate)")
    parser.add_argument('-mut_size', type=float, default=0.5, help="size of mutation")
    parser.add_argument('-num_generations', type=int, default=10, help="number of generations to run the experiment for") # number of generations
    parser.add_argument('-truncation_prop', type=float, default=0.2, help="proportion of individuals selected for reproduction")
    parser.add_argument('-max_age', type=int, default=5, help="max age at which individual is replaced by its kid")
    parser.add_argument('-season_len', type=int, default=5, help="number of generations between environmental flips")
    parser.add_argument('-proj', type=str, default="EC_final_project", help="Name of the project (for wandb)")
    parser.add_argument('-exp_type', type=str, default="BASIC", help="Name your experiment for grouping")
    #parser.add_argument('-rep', type=str, default="1", help="ID of replicate")

    args = parser.parse_args()

    print("running code")

    args.truncation_size=int(args.truncation_prop*args.pop_size)

    if args.pop_size % args.truncation_size != 0:
      print("Error: select different trunction_prop")
      break

    #tag = conf2tag(vars(args))
    wandb.init(config=args, project=args.proj, group=args.exp_type)

    evolutionary_algorithm(args)





#plt.figure(figsize=(18, 10))
#plt.plot(max_fits)
#plt.tight_layout()
#plt.title("max fitness is "+str(N*M))
#plt.show()

#plt.plot(ave_complex)
#plt.tight_layout()
#plt.title("max complexity is "+str(lifetime))
#plt.show()

#plt.figure(figsize=(18, 10))
#plt.plot(max_ages)
#plt.tight_layout()
#plt.show()

#c = np.stack(champions)  # + [targ.cpu().detach().clone().squeeze(0).numpy()])
#d = c.mean(axis=0).argsort()
#plt.figure(figsize=(18, 10))
# plt.imshow(c.T, interpolation="nearest")
#plt.imshow(c[:, d].T, interpolation="nearest")
#plt.ylabel("GENE")
#plt.xlabel("Epoch")
#plt.tight_layout()
#plt.colorbar()
#plt.show()
